//  Licensed to the Apache Software Foundation (ASF) under one
//  or more contributor license agreements.  See the NOTICE file
//  distributed with this work for additional information
//  regarding copyright ownership.  The ASF licenses this file
//  to you under the Apache License, Version 2.0 (the
//  "License"); you may not use this file except in compliance
//  with the License.  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing,
//  software distributed under the License is distributed on an
//  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//  KIND, either express or implied.  See the License for the
//  specific language governing permissions and limitations
//  under the License.

import Foundation

/// A Packrat grammar is a collection of parsing rules, one of which is the designated `start` rule.
public protocol PackratGrammar {
  /// The designated starting rule for parsing the grammar. This rule should produce exactly one syntax tree `Node`.
  var start: ParsingRule { get }
}

/// Implements a packrat parsing algorithm.
public final class PackratParser {
  /// Designated initializer.
  /// - Parameters:
  ///   - buffer: The content to parse.
  ///   - grammar: The grammar rules to apply to the contents of `buffer`
  // TODO: This should probably take a block that constructs a grammar rather than a grammar
  public init(buffer: PieceTable, grammar: PackratGrammar) {
    self.buffer = buffer
    self.grammar = grammar
    self.memoizedResults = Array(repeating: ResultsAtIndex(), count: buffer.endIndex + 1)
  }

  /// The contents to parse.
  public let buffer: PieceTable

  /// The grammar rules to apply to the contents of `buffer`.
  public let grammar: PackratGrammar

  /// If any rules are tracing evaluation, the trace entries are stored here.
  public let traceBuffer = TraceBuffer()

  /// Parses the contents of the buffer.
  /// - Throws: If the grammar could not parse the entire contents, throws `Error.incompleteParsing`. If the grammar resulted in more than one resulting node, throws `Error.ambiguousParsing`.
  /// - Returns: The single node at the root of the syntax tree resulting from parsing `buffer`
  public func parse() throws -> Node {
    let result = grammar.start.apply(to: self, at: 0)
    guard let node = result.node, result.length == buffer.endIndex else {
      throw Error.incompleteParsing(length: result.length)
    }
    return node
  }

  /// Returns the memoized result of applying a rule at an index into the buffer, if it exists.
  public func memoizedResult(rule: ObjectIdentifier, index: Int) -> ParsingResult? {
    return memoizedResults[index][rule]
  }

  /// Memoizes the result of applying a rule at an index in the buffer.
  /// - Parameters:
  ///   - result: The parsing result to memoize.
  ///   - rule: The
  ///   - index: <#index description#>
  public func memoizeResult(_ result: ParsingResult, rule: ObjectIdentifier, index: Int) {
    memoizedResults[index][rule] = result
  }

  // MARK: - Supporting types

  public enum Error: Swift.Error {
    /// The supplied grammar did not parse the entire contents of the buffer.
    /// - parameter length: How much of the buffer was consumed by the grammar.
    case incompleteParsing(length: Int)

    /// The supplied grammar consumed the entire buffer but resulted in more than one top-level node.
    /// - parameter nodes: The nodes generated by parsing.
    case ambiguousParsing(nodes: [Node])
  }

  // MARK: - Memoization internals

  private typealias ResultsAtIndex = [ObjectIdentifier: ParsingResult]
  private var memoizedResults: [ResultsAtIndex]
}
